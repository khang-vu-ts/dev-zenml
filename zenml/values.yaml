mysql:
  global:
    name: mysql
    storageClass: "zenml-storageclass"
  primary:
    persistence:
      enabled: true
      size: 20Gi
  secondary:
    persistence:
      enabled: true
      size: 20Gi
  auth:
    rootPassword: "zenml"
    createDatabase: true
    database: "zenml"
    username: "zenml"
    password: "zenml"

zenml:
  zenml:
    image:
      repository: zenmldocker/zenml-server
      pullPolicy: IfNotPresent

    database:
      url: "mysql://zenml:zenml@zenml-mysql:3306/zenml"
      ssl: false

    secure_headers:
      server: enabled
      # The `Strict-Transport-Security` HTTP header value. The default value is
      # `max-age=63072000; includeSubDomains`.
      hsts: enabled
      # The `X-Frame-Options` HTTP header value. The default value is `SAMEORIGIN`.
      xfo: enabled
      # The `X-XSS-Protection` HTTP header value. The default value is `0`.
      # NOTE: this header is deprecated and should not be customized anymore. The
      # `Content-Security-Policy` header should be used instead.
      xxp: enabled
      # The `X-Content-Type-Options` HTTP header value. The default value is
      # `nosniff`.
      content: enabled
      # The `Content-Security-Policy` HTTP header value. This is by default set
      # to a strict CSP policy that only allows content from the origins required
      # by the ZenML dashboard.
      # NOTE: customizing this header is discouraged, as it may cause the ZenML
      # dashboard to malfunction.
      csp: enabled
      # The `Referrer-Policy` HTTP header value. The default value is
      # `no-referrer-when-downgrade`.
      referrer: enabled
      # The `Cache-Control` HTTP header value. The default value is
      # `no-store, no-cache, must-revalidate`.
      cache: enabled
      # The `Permissions-Policy` HTTP header value. The default value is
      # `accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()`.
      permissions: enabled

    secretsStore:
      enabled: true
      # The type of secrets store to use. Use one of:
      #
      # sql - Use the same SQL database as the ZenML server
      # aws - Use the AWS Secrets Manager as a secrets store
      # gcp - Use the GCP Secrets Manager as a secrets store
      # azure - Use the Azure Key Vault as a secrets store
      # hashicorp - Use the HashiCorp Vault as a secrets store
      # custom - Use a custom secrets store implementation (needs a custom
      #          ZenML server image with the custom secrets store implementation
      #          installed)
      #
      # Depending on the type, additional configuration options may be required
      # under the respective sections.
      type: sql
      # SQL backup secrets store configuration. Only relevant if the `sql` backup
      # secrets store type is configured.
      sql:
        encryptionKey: "zenml"

      gcp:
        # The GCP Service Connector authentication method to use. The currently
        # supported authentication methods are:
        #
        # - implicit - Use the GCP service account attached to the ZenML server
        #              pod or environment variables to authenticate with the GCP
        #              Secrets Manager API
        # - user-account - Use a GCP user account
        # - service-account - Use a GCP service account
        # - impersonation - Use the GCP service account impersonation feature
        authMethod: service-account
        # The GCP Service Connector authentication configuration. This should
        # include the corresponding authentication configuration attributes for
        # the `authMethod` that you have chosen above.
        authConfig:
          project_id:
          # The GCP user account credentials to use to authenticate with the GCP
          # Secrets Manager instance. Required if the `authMethod` is set to
          # `user-account`.
          user_account_json:
          # The GCP service account credentials to use to authenticate with the
          # GCP Secrets Manager instance. Required if the `authMethod` is set to
          # `service-account` or `impersonation`.
          service_account_json:

    backupSecretsStore:
      enabled: false
      gcp:
        # The GCP Service Connector authentication method to use for the backup
        # secrets store. The currently supported authentication methods are:
        #
        # - implicit - Use the GCP service account attached to the ZenML server
        #              pod or environment variables to authenticate with the GCP
        #              Secrets Manager API
        # - user-account - Use a GCP user account
        # - service-account - Use a GCP service account
        # - impersonation - Use the GCP service account impersonation feature
        authMethod: service-account
        # The GCP Service Connector authentication configuration for the backup
        # secrets store. This should include the corresponding authentication
        # configuration attributes for the `authMethod` that you have chosen above.
        authConfig:
          # The GCP project ID to use. This must be set to the project ID where
          # the GCP Secrets Manager service that you want to use is located.
          # Mandatory for all authentication methods.
          project_id:
          # The GCP user account credentials to use to authenticate with the GCP
          # Secrets Manager instance. Required if the `authMethod` is set to
          # `user-account`.
          user_account_json:
          # The GCP service account to impersonate when authenticating with the
          # GCP Secrets Manager instance. Required if the `authMethod` is set to
          # `impersonation`.
          service_account_json:
          # The GCP workload identity credentials to use to authenticate with the
          # GCP Secrets Manager instance. Required if the `authMethod` is set to
          # `external-account`.
          target_principal:
          # The GCP workload identity credentials to use to authenticate with the
          # GCP Secrets Manager instance. Required if the `authMethod` is set to
          # `external-account`.
          external_account_json:
          
    debug: true
    defaultProject: default
    auth:
      authType: OAUTH2_PASSWORD_BEARER
      jwtTokenAlgorithm: HS256
      jwtTokenLeewaySeconds: 10
      maxFailedDeviceAuthAttempts: 5
      deviceAuthTimeout: 300
      deviceAuthPollingInterval: 5

    ingress:
      enabled: true
      annotations:
        cert-manager.io/cluster-issuer: "letsencrypt-prod"
        # nginx.ingress.kubernetes.io/ssl-redirect: "true"
        # nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
        nginx.ingress.kubernetes.io/proxy-body-size: "0"
      host: zenml.potholescannerapi.io.vn
      tls:
        enabled: true
        generateCerts: false

    service:
      type: ClusterIP
      port: 80

  serviceAccount:
    create: true
    name: zenml